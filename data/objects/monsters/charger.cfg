{
id:          "charger",
prototype:   ["hittable"],
editor_info: { category: "Monsters" },

solid_dimensions:   ["player","common"],
collide_dimensions: ["common"],
has_feet:           false,
zorder:             "@include data/zorder.cfg:npcs",
hitpoints:          60,

properties: {
	topdownFriction: "2.0",
	attackDamage:    "3",

	wanderBaseVelocity_: "decimal :: 55",
	windupBaseVelocity_: "decimal :: 30",
	chargeBaseVelocity_: "decimal :: 200",
	
	wanderVelocityXY_: "[decimal, decimal] ::
		[wanderBaseVelocity_ * cos(randAngle),
		 wanderBaseVelocity_ * sin(randAngle)]
			where randAngle = 1d360",
	
	// Most durations/delays are handled by animations
	chargeWindupDuration_: "int :: 75",
	
	crashDamage_:  "int     :: 20",    // Damage taken when charing into a wall
	crashRebound_: "decimal :: -5.0",  // Multiplyer to velocity upon hitting wall
	hitRebound_:   "decimal :: -3.0",  // Multiplyer to velocity upon hitting object
	
	targetVelocityXY: {type: '[decimal]', default: [0, 0]},

	/******
	 * AI *
	 ******/
	BeginCharge: "def([int] targetXY) -> commands [
		
		// We used to 'wind up' before charging, but it caused issues
		set(animation, 'windup'),
		set(targetVelocityXY,
			[0, 0]
			/*[windupBaseVelocity_ * cos(180 + targetAngle),
			 windupBaseVelocity_ * sin(180 + targetAngle)]*/
		),
		
		// Schedule the charge itself
		schedule(chargeWindupDuration_, [
			set(animation, 'charge'),
			set(targetVelocityXY,
				[chargeBaseVelocity_ * cos(targetAngle),
				 chargeBaseVelocity_ * sin(targetAngle)]
			)
		])
	] where targetAngle =
		angle(me.mid_x, me.mid_y, level.player.mid_x, level.player.mid_y)
	",
	
	Wander: "def() -> commands [
		set(targetVelocityXY, wanderVelocityXY_),
		animation('wander')
	]",
	EndWander: "def() -> commands [
		set(targetVelocityXY, [0, 0]),
		animation('normal')
	]",

	Move: "def() -> commands [
		add(velocity_x, targetVelocityXY[0]),
		add(velocity_y, targetVelocityXY[1])
	]",

	DoCollide: "def(null|custom_obj collide_with) -> commands
		if(animation = 'charge',
			if(collide_with is obj hittable,
				ReactToHit(obj hittable <- collide_with),  // We hit something! Do damage to it!
				ReactToCrash()                             // We charged into a wall!
			),
			Wander() // We walking into a wall; change dir.
		)
	",

	ReactToHit: "def(obj hittable collide_with) -> commands [
		set(velocity_x, velocity_x * hitRebound_),
		set(velocity_y, velocity_y * hitRebound_),
		set(targetVelocityXY, [0, 0]),
		execute(collide_with, collide_with.GetHitBy(me)), // TODO: Make this work; self damage atm
		
		set(animation, 'huzzah')
	]",

	ReactToCrash: "def() -> commands [
		set(velocity_x, velocity_x * crashRebound_),
		set(velocity_y, velocity_y * crashRebound_),
		set(targetVelocityXY, [0, 0]),
		GetHitSourceless('none', crashDamage_),

		set(animation, 'dizzy')	// The dizzy animation ends itself
	]",

}, // End of properties

on_process: "[
	Move();
	DoFriction()
]",

on_collide_head: "DoCollide(arg.collide_with)",
on_collide_side: "DoCollide(arg.collide_with)",
on_collide_feet: "DoCollide(arg.collide_with)",

on_hear_sound: "
	if(animation in ['normal', 'wander'],
		BeginCharge([int] <- arg.sourceXY)
	)
",

on_end_normal_anim: "Wander()",
on_end_wander_anim: "EndWander()",


on_end_dizzy_anim:  "animation('normal')",
on_end_huzzah_anim: "animation('normal')",

animation: [
	{
		"@base": true,
		image: "blank.png",
		rect:  [0, 0, 23, 23],
		solid_area: [0, 0, 23, 23],
		body_area:  'all',
		
		duration: 1,
	},
	{
		id:    "normal",
		duration: 90	
	},
	{
		id:    "wander",
		duration: 70	
	},
	{
		id:    "windup",
	},
	{
		id:    "charge",
//		attack_area: 'all'	
	},
	{
		id:    "dizzy",
		duration: 100
	},
	{
		id:    "huzzah",
		duration: 100
	},

] // End of animation

} // End of file
