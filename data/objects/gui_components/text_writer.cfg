//A health display, in the style of hearts. One hitpoint is half a heart.
{
	id: "text_writer",
	is_strict: true,
	use_absolute_screen_coordinates: true,
	hidden_in_game: true,
	serializable: false,
	
	editor_info: { category: "Characters" },
	zorder: "@include data/zorder.cfg:in_front_of_everything",

	properties: {
		//target: { type: "custom_obj" },
		target: "custom_obj <- lp asserting lp where lp = level.local_player",

		buffer: { type: 'string', default: 'Explode explode boom pow' },
		prepped_buffer: { type: 'string', default: '' },
		display: { type: 'string', default: '' },
		font: { type: 'string', default: 'white_outline' },
		
		window_width: { type: 'int', init: 70 },

		# A string must be expanded to be able to be reversed
		reverse_string: "def(string input) -> string
			fold( reverse( map(range(size(input)), value, string <- input[value]) ), a+b)",
			
	    tail: "def(string input) -> string
			if(input != '', input[:size(input)-1], input)", // Drop last element
		behead: "def(string input) -> string
			input[1:]",             // Drop first
		
		# Steps:
		#  Pull a chunk of text off our buffer
		#  Recursively give back letters from the end
		#    until the character is a space; replace it with a \n
		#  Get the next chunk, if there is more text.
		
		prep_buffer: "def(string unprocessed) -> string
			if(size(unprocessed) < window_width,	// If what we have left doesn't need to be broken up
				unprocessed,						// Finish looping
				new_chunk + '\n' + prep_buffer( behead(remaining_chunk) ) // Behead drops the leading space
			)				
				where new_chunk = unprocessed[:find_last_space(unprocessed[:window_width])]
				where remaining_chunk = unprocessed[find_last_space(unprocessed[:window_width]):]
		",
		
		
		
		# Note that size gives one beyond the string's end, hence the size - 1
		find_last_space: "def(string input) -> int
			_find_last_space(input, size(input) - 1)",
			
		_find_last_space: "def(string input, int offset) -> int
			if(offset > 0,	// Make sure we are not at thes tart of the string
				if(input[offset] = ' ',
					offset,							// Return, +1 includes space
					_find_last_space(input, offset-1)	// Loop again
				),
				size(input) -1	// This gets run if there are no spaces in our input;
			)"					//  returns the index to the last character in the string
	},
	
	timer_frequency: 3,
	on_timer: "if(prepped_buffer != '', [
		set(display, display + prepped_buffer[0:1]),
		set(prepped_buffer, behead(prepped_buffer))
		] )",

	on_process: "text(display, font)",
	on_create: "set(prepped_buffer, prep_buffer(buffer))",
}
