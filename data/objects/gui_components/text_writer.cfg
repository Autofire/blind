//A health display, in the style of hearts. One hitpoint is half a heart.
{
	id: "text_writer",
	is_strict: true,
	use_absolute_screen_coordinates: true,
	hidden_in_game: true,
	serializable: false,
	
	editor_info: { category: "Characters" },
	zorder: "@include data/zorder.cfg:in_front_of_everything",

	properties: {
		//target: { type: "custom_obj" },
		target: "custom_obj <- lp asserting lp where lp = level.local_player",

		speaker: { type: 'string', default: '' },	// In the case of dialog, this says who's talking.
		buffer: { type: 'string', default: '' },
		_buffer: { type: 'string', default: '' },
		stored_buffer: { type: '[string]', default: [''] },
		display: { type: 'string', default: '' },

		font: { type: 'string', default: 'white_outline' },
		
		window_width:  { type: 'int', default: 70 },
		window_height: { type: 'int', default: 3 },

		# A string must be expanded to be able to be reversed
		reverse_string: "def(string input) -> string
			fold( reverse( map(range(size(input)), value, string <- input[value]) ), a+b)",
			
	    tail: "def(string input) -> string
			if(input != '', input[:size(input)-1], input)", // Drop last element
		head: "def(string input) -> string
			input[:1]",				// Keep first
		behead: "def(string input) -> string
			input[1:]",             // Drop first
		
		//
		clear_display: "[
			add(stored_buffer, [display]),
			set(display, '')
		]",

		// Steps:
		//  Pull a chunk of text off our buffer
		//  Recursively give back letters from the end
		//    until the character is a space; replace it with a \n
		//  Get the next chunk, if there is more text.
		prep_buffer: "set(_buffer, _prep_buffer(buffer, 1))",
		_prep_buffer: "def(string unprocessed, int newlines) -> string
			if(size(unprocessed) < window_width,	// If what we have left doesn't need to be broken up
				unprocessed,						// Finish looping
				new_chunk
				 + if(newlines % 3 = 0, '_', '\n')			// '_' is our 'new window' character
				 + _prep_buffer( behead(remaining_chunk), newlines + 1 ) // Behead drops the leading space
			)				
				where new_chunk = unprocessed[:find_last_space(unprocessed[:window_width])]
				where remaining_chunk = unprocessed[find_last_space(unprocessed[:window_width]):]
		",
		
		// Note that size gives one beyond the string's end, hence the size - 1
		find_last_space: "def(string input) -> int
			_find_last_space(input, size(input) - 1)",
			
		_find_last_space: "def(string input, int offset) -> int
			if(offset > 0,	// Make sure we are not at thes tart of the string
				if(input[offset] = ' ',
					offset,							// Return, +1 includes space
					_find_last_space(input, offset-1)	// Loop again
				),
				size(input) -1	// This gets run if there are no spaces in our input;
			)"					//  returns the index to the last character in the string
	},
	
	timer_frequency: 3,
	on_timer: "if(_buffer != '' and _buffer[:1] != '_', [
		set(display, display + _buffer[:1]),
		set(_buffer, behead(_buffer))
		] )",

	on_process: "text(display, font)",
	on_create: "prep_buffer",
}
