// The writer of the game's text. Handles page breaks and wordwrapping.
//
// TODO: Make it so that new text directly following a display clear does
// not involve a pause. (Maybe something in on_timer?
//
// TODO: Cause the processor to observe newlines and pagebreaks inside of
// input text. (As of now, it botches such input.)
//
// VERY IMPORTANT TODO: Make processor dynamically pick up words and
// process, rather than processing everything before beginning to print
// anything. (This would require the processor to "look forward" and find
// how long the word is, in order to know when to break it up.) The
// advantage of this is that it's much more flexable with formatting in the
// input strings.
{
id: "text_writer",
is_strict: true,
use_absolute_screen_coordinates: true,
hidden_in_game: true,
serializable: false,

editor_info: { category: "controllers, gui" },
zorder: "@include data/zorder.cfg:in_front_of_everything",

properties: {
	"@derive": "@include data/object_prototypes/core/standard_values.cfg:properties",
	c_IgnoreMissingTimers: "false",

	/*************
	 * VARIABLES *
	 *************/
	defaultWait: { type: 'int', default: 2 },
	
	
	/*************
	 * FUNCTIONS *
	 *************/
	// Call this in on_process. It attempts to update the buffer properly,
	// and accomidates for escape characters. DOES NOT AUTO-LINEBREAK.
	UpdateDisplay: "def() -> commands
		if( buffer != '' and Timer_HasExpired(buffer),
				if(buffer[0] = '_',
					debug('DoEscape'), //buffer = DoEscape(buffer),
					[   set(display, display + buffer[0]),
						set(buffer, buffer[1:]),
						Timer_Start(buffer[1:], defaultWait)
					]
				)
		)
	",
	
	
				    

	// OLD
	//target: { type: "custom_obj" },
	target: "custom_obj <- lp asserting lp where lp = level.local_player",

	speaker: { type: 'string', default: '' },	// In the case of dialog, this says who's talking.
	buffer: { type: 'string', default: '' },
//		_buffer: { type: 'string', default: '' },
	stored_buffer: { type: '[string]', default: ['End of log'] },
	display: { type: 'string', default: '' },

	font: { type: 'string', default: 'white_outline' },
	
	window_width:  { type: 'int', default: 68 },
	window_height: { type: 'int', default: 3 },

	// This is how long it takes for the next window to appear
	window_delay: { type: 'int', default: 30 },
	// This is a holder for how much time has passed
	window_countdown: { type: 'int', default: 0 },

	// This is our special character for pagebreaks.
	// This character shouldn't ever be used in the game's text.
	page_break: "string :: '_'",

	# A string must be expanded to be able to be reversed
	reverse_string: "def(string input) -> string
		fold( reverse( map(range(size(input)), value, string <- input[value]) ), a+b)",
		
	tail: "def(string input) -> string
		if(input != '', input[:size(input)-1], input)", // Drop last element
	head: "def(string input) -> string
		input[:1]",				// Keep first
	behead: "def(string input) -> string
		input[1:]",             // Drop first
	
	add_text: "def(string text, string speaker = '') -> commands
		add(buffer,
			if(display != '', page_break, '') // If nothing is up, we don't want to wait for the new text
			+ prep_buffer(text, if(speaker != '', speaker + ': ', '')
		))",
	clear_display: "[
		add(stored_buffer, [display]),
		set(display, '')
	]",
	clear_everything: "[
		clear_display,
		set(buffer, '')
	]",

	// Steps:
	//  Pull a chunk of text off our buffer
	//  Recursively give back letters from the end
	//    until the character is a space; replace it with a \n
	//  Get the next chunk, if there is more text.
//		_prep_buffer: "set(_buffer, _prep_buffer(buffer, 1))",
	prep_buffer: "def(string unprocessed, string speaker, int newlines = 1) -> string
		if(line_length < window_width,		// If what we have left doesn't need to be broken up,
			unprocessed,					//  Finish looping
			if(newlines % 3 = 1, speaker, '')	// Print the speaker's name if its the first line
			 + new_chunk
			 + if(newlines % 3 = 0, page_break, '\n\n')
			 + prep_buffer( behead(remaining_chunk), speaker, newlines + 1 ) // Behead drops the leading space
		)		// For line_length, we want to include the speaker's name
			where line_length = size(unprocessed) + if(newlines % 3 = 1, size(speaker), 0)
			where new_chunk = unprocessed[:find_last_space(unprocessed[:window_width])]
			where remaining_chunk = unprocessed[find_last_space(unprocessed[:window_width]):]
	",
	
	// Note that size gives one beyond the string's end, hence the size - 1
	find_last_space: "def(string input) -> int
		_find_last_space(input, size(input) - 1)",
		
	_find_last_space: "def(string input, int offset) -> int
		if(offset > 0,	// Make sure we are not at thes tart of the string
			if(input[offset] = ' ',
				offset,							// Return, +1 includes space
				_find_last_space(input, offset-1)	// Loop again
			),
			size(input) -1	// This gets run if there are no spaces in our input;
		)"					//  returns the index to the last character in the string
},

timer_frequency: 2,
/*
on_timer: "if(buffer != '',
		if(buffer[:1] != page_break, [
			set(display, display + buffer[:1]),
			set(buffer, behead(buffer)),
			set(window_countdown, window_delay),
			],
			// This runs on page breaks unless the page is already
			// blank; in that case, just keep going.
			if(window_countdown > 0,
				add(window_countdown, -1),
				[clear_display,
				 set(buffer, behead(buffer)),
				 set(window_countdown, window_delay)]
			)
		)
	)",
	*/

//	on_next_window: "if(_buffer[:1] = page_break....",

on_process: "[
	UpdateDisplay(),
	text(display, font),
	// Prevent the display from slowing down if it's clear
//	if(display = '' and buffer[:1] = page_break,
//		set(buffer, behead(buffer))
//	)
]",

//	on_create: "prep_buffer",
}
