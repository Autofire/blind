// The writer of the game's text. Handles page breaks and wordwrapping.
//
// TODO: Make it so that new text directly following a display clear does
// not involve a pause. (Maybe something in on_timer?
//
// TODO: Cause the processor to observe newlines and pagebreaks inside of
// input text. (As of now, it botches such input.)
//
// VERY IMPORTANT TODO: Make processor dynamically pick up words and
// process, rather than processing everything before beginning to print
// anything. (This would require the processor to "look forward" and find
// how long the word is, in order to know when to break it up.) The
// advantage of this is that it's much more flexable with formatting in the
// input strings.
{
id: "text_writer",
is_strict: true,
use_absolute_screen_coordinates: true,
hidden_in_game: true,
serializable: false,

editor_info: { category: "controllers, gui" },
zorder: "@include data/zorder.cfg:in_front_of_everything",

properties: {
	"@derive": "@include data/object_prototypes/core/standard_values.cfg:properties",

	/*************
	 * CONSTANTS *
	 *************/
	linesPerPage_: "int :: 3",		// Used for automatic page-breaks
	charsPerLine_: "int :: 68",		// Used for automatic line-breaks
	escapeChar_:   "string :: '_'",	// Character which escape sequences are
									// surrounded by. MUST BE ONE CHAR.

	/*************
	 * VARIABLES *
	 *************/
	buffer:  { type: 'string', default: '' },	// Post-processed output string
	display: { type: 'string', default: '' },	// Currently displayed text
	history: { type: '[string]',
	           default: ['End of history'] },	// Keeps old pages

	defaultCharWait: { type: 'int', default: 2  }, // Cycles until next character
	defaultPageWait: { type: 'int', default: 100}, // Cycles until page change

	linesOnPage: { type: 'int', default: 0 }, // Tracks newlines (for pagebreaking)
	
	
	/*************
	 * FUNCTIONS *
	 *************/

	/*************************************************************************
	 *   UpdateDisplay:
	 * Steps through the buffer, respecting all possible escape sequences.
	 * It also respects the timers 'PageBreakCountdown' and the current
	 * buffer. In order to stop execution, the timer for the current buffer
	 * should be set. This means that, when creating a timer, typically the
	 * idea is to create it with the name of the buffer AFTER the current
	 * opperation. This could either mean cutting a character/escape sequnce
	 * and then making the timer.
	 *
	 * Note that this doesn't automatically word wrap on it's own. Also, it
	 * has a special exception for newline characters. Specifically, it
	 * calls DoEscape with '_n_' to trigger all the special effects of our
	 * newline escape character.
	 *************************************************************************/
	UpdateDisplay: "def() -> commands
		if(Timer_HasExpired('PageBreakCountdown'),
		
			if(buffer != '' and Timer_HasExpired(buffer),
				if(buffer[0] = escapeChar_,
					[   DoEscape(buffer),
						set(buffer, DeleteEscape(buffer))
					],
				   buffer[0] = '\n',	// else if
				    [   DoEscape('_n_'),// Catch true newlines
						set(buffer, buffer[1:])
					],
				   // else; print one character
					[   set(display, display + buffer[0]),
						Timer_Start(buffer[1:], defaultCharWait),
						set(buffer, buffer[1:])
					]
				)
			), // End if(buffer != '' and Timer_HasExpired(buffer), ... )
			
			if(Timer_RemainingTime('PageBreakCountdown') = 1,
				DoPageBreak()
			)
			
		) // End if(Timer_HasExpired('PageBreakCountdown'), ... )
	",

	/*************************************************************************
	 *   DoEscape:
	 * Do everything related to escape sequences, other than cutting the
	 * escape sequence out of the input. (The calling function has to do
	 * this.) Assuming that escapeChar_ = '_', the possible escape sequences
	 * are:
	 *
	 *  _n_    | New line, or new page, if necessary. Can NOT be
	 *         | substituted by a regular newline, (i.e. '\n') although
	 *         | UpdateDisplay() accounts for this.
	 *         |
	 *  _p100_ | Force a new page, waiting given cycles before moving to new
	 *         | page. Leaving out the number will use defaultPageWait
	 *         | instead. If a number is given, it must be at least 2.
	 *         |
	 *  _P200_ | Sets the default wait time on each page break, AND creates a
	 *         | new page with this set wait time. (TODO)
	 *         |
	 *  _w100_ | Pause output for the specified number of cycles. (100, in
	 *         | this case.) This overwrites the default wait time.
	 *         |
	 *  _W30_  | Set the default wait time on each character. If no time is
	 *         | given, the engine reverts to the default time. takes effect
	 *         | instantly. (TODO)
	 *         |
	 *  _e..._ | Evaluate the given command. (TODO)
	 *         |
	 *  _any_  | If random junk is given, the function will print an error
	 *         | in the debug output, but nothing else happens.
	 * 
	 *
	 *   Note on DoEscape()'s where statements:
	 * split() produces a list of strings. Since DoEscape is only called
	 * when the first character is an underscore, the result of split()
	 * will always be ['', <escape sequence>, ...].  Selecting the second
	 * element of this list, then will get us the entire escape seqence.
	 * Because this isn't too useful, there are two where statements, each
	 * which extract useful info.
	 *************************************************************************/
	DoEscape: "def(string inStr) -> commands (
		switch(escapeType_,
		
			       // Will we roll over by adding another newline?
			'n',if(linesOnPage + 1 >= linesPerPage_,
					CuePageBreak(),
					[   set(display, display + '\n'),
						add(linesOnPage, 1)
					]
				),
				
			'p',CuePageBreak(int(escapeValue_)),
			
			'w',Timer_Start( DeleteEscape(buffer), int(escapeValue_) ),
			
			// Default action
			debug('WARNING: \"' + escapeType_ +
			      '\" IS NOT A VALID ESCAPE CHARACTER.')
			
		) // End of switch(escapeType_, ...)
			
			where escapeType_    = escapeString_[0]
			where escapeValue_   =
				if(size(escapeString_) > 1,
					escapeString_[1:],   // Only try this is a value to grab!
					0					// Something safe if no value given
				)
				
	) where escapeString_ = split(inStr, escapeChar_)[1]
	",

	/*************************************************************************
	 *   DeleteEscape:
	 * Return the inputted string without the first escape sequence. Assumes
	 * that the escape sequence is at the very start of the string and is
	 * delimited by underscores.
	 *************************************************************************/	
	DeleteEscape: "def(string inStr) -> string
		inStr[secondDelimiter_ + 1 : ]
			where secondDelimiter_ = FindChar(inStr, escapeChar_)[1]
	",

	/*************************************************************************
	 *   CuePageBreak:
	 * Cue up a new page, using the default wait time if no other time is
	 * specified.
	 *************************************************************************/
	CuePageBreak: "def(int delay = 0) -> commands [
		if(delay != 0,
			Timer_Start('PageBreakCountdown', delay),
			Timer_Start('PageBreakCountdown', defaultPageWait)
		)
	]",

	/*************************************************************************
	 *   DoPageBreak:
	 * Create a new page and save the old one.
	 *************************************************************************/
	DoPageBreak: "def() -> commands [
		set(history, [display] + history),
		set(display, ''),
		set(linesOnPage, 0)
	]",


	WordWrap: "def(string inStr) -> string
		_WordWrap( CutEscapeSequences(inStr) )
	",

	_WordWrap: "def(string inStr) -> string
		if(size(inStr) > charsPerLine_,
			// Do linebreak stuff and return.
			inStr[:wrapPoint - 1] + '\n' + _WordWrap(inStr[wrapPoint:]),

			// The string is short enough! Return it.
			inStr	// else
		) where wrapPoint =
				choose(
					filter(
						FindChar(inStr, ' '),
						value <= charsPerLine_ // Drop those too great
					),
					value	// Pick the largest of the remaining
				)
	",


	/*************************************************************************
	 *   FindChar:
	 * Handy character-finder. Returns all of the indicies where the character
	 * appears.
	 *************************************************************************/
	FindChar: "def(string inStr, string searchChar) -> [int]
		filter(
			map(inStr, if(value = searchChar, index) ),
			value != null
		)
	",
	 
	/*************************************************************************
	 *   CutEscapeSequences:
	 * Drops ALL escape sequences from the string passed it, and then
	 * returns it.
	 *************************************************************************/
	CutEscapeSequences: "def(string inStr) -> string
		fold(
			filter(
				map(split(inStrWithoutNewlines, escapeChar_),
					if(index % 2 = 0, value, null) // Get even values only.
				),
				value != null
			),
			a+b
		) // End of fold()
		where inStrWithoutNewlines =
				fold(filter(map(inStr, value), value != '\n'), 
					 (string <- a) + (string <- b) // Necessary
				)
	",
	

	// OLD
	//target: { type: "custom_obj" },
	target: "custom_obj <- lp asserting lp where lp = level.local_player",

	speaker: { type: 'string', default: '' },	// In the case of dialog, this says who's talking.
//		_buffer: { type: 'string', default: '' },
	stored_buffer: { type: '[string]', default: ['End of log'] },

	font: { type: 'string', default: 'white_outline' },
	
	window_width:  { type: 'int', default: 68 },
	window_height: { type: 'int', default: 3 },

	// This is how long it takes for the next window to appear
	window_delay: { type: 'int', default: 30 },
	// This is a holder for how much time has passed
	window_countdown: { type: 'int', default: 0 },

	// This is our special character for pagebreaks.
	// This character shouldn't ever be used in the game's text.
	page_break: "string :: '_'",

	# A string must be expanded to be able to be reversed
	reverse_string: "def(string input) -> string
		fold( reverse( map(range(size(input)), value, string <- input[value]) ), a+b)",
		
	tail: "def(string input) -> string
		if(input != '', input[:size(input)-1], input)", // Drop last element
	head: "def(string input) -> string
		input[:1]",				// Keep first
	behead: "def(string input) -> string
		input[1:]",             // Drop first
	
	add_text: "def(string text, string speaker = '') -> commands
		add(buffer,
			if(display != '', page_break, '') // If nothing is up, we don't want to wait for the new text
			+ prep_buffer(text, if(speaker != '', speaker + ': ', '')
		))",
	clear_display: "[
		add(stored_buffer, [display]),
		set(display, '')
	]",
	clear_everything: "[
		clear_display,
		set(buffer, '')
	]",

	// Steps:
	//  Pull a chunk of text off our buffer
	//  Recursively give back letters from the end
	//    until the character is a space; replace it with a \n
	//  Get the next chunk, if there is more text.
//		_prep_buffer: "set(_buffer, _prep_buffer(buffer, 1))",
	prep_buffer: "def(string unprocessed, string speaker, int newlines = 1) -> string
		if(line_length < window_width,		// If what we have left doesn't need to be broken up,
			unprocessed,					//  Finish looping
			if(newlines % 3 = 1, speaker, '')	// Print the speaker's name if its the first line
			 + new_chunk
			 + if(newlines % 3 = 0, page_break, '\n\n')
			 + prep_buffer( behead(remaining_chunk), speaker, newlines + 1 ) // Behead drops the leading space
		)		// For line_length, we want to include the speaker's name
			where line_length = size(unprocessed) + if(newlines % 3 = 1, size(speaker), 0)
			where new_chunk = unprocessed[:find_last_space(unprocessed[:window_width])]
			where remaining_chunk = unprocessed[find_last_space(unprocessed[:window_width]):]
	",
	
	// Note that size gives one beyond the string's end, hence the size - 1
	find_last_space: "def(string input) -> int
		_find_last_space(input, size(input) - 1)",
		
	_find_last_space: "def(string input, int offset) -> int
		if(offset > 0,	// Make sure we are not at thes tart of the string
			if(input[offset] = ' ',
				offset,							// Return, +1 includes space
				_find_last_space(input, offset-1)	// Loop again
			),
			size(input) -1	// This gets run if there are no spaces in our input;
		)"					//  returns the index to the last character in the string
},

timer_frequency: 2,
/*
on_timer: "if(buffer != '',
		if(buffer[:1] != page_break, [
			set(display, display + buffer[:1]),
			set(buffer, behead(buffer)),
			set(window_countdown, window_delay),
			],
			// This runs on page breaks unless the page is already
			// blank; in that case, just keep going.
			if(window_countdown > 0,
				add(window_countdown, -1),
				[clear_display,
				 set(buffer, behead(buffer)),
				 set(window_countdown, window_delay)]
			)
		)
	)",
	*/

//	on_next_window: "if(_buffer[:1] = page_break....",

on_process: "[
	UpdateDisplay(),
	text(display, font),
	// Prevent the display from slowing down if it's clear
//	if(display = '' and buffer[:1] = page_break,
//		set(buffer, behead(buffer))
//	)
]",

//	on_create: "prep_buffer",
}
