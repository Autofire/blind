# blind_playable.cfg
# The player character
# Search for IMPORTANT before making any big changes
# TODO:
# Yellow: write code that helps get player around edges.

{

#DEFINES#
id: "blind_playable",

prototype: [
	// Player_specific prototypes
	"shaders_",
	"text_handler_",
	"sequence_handler_",
	"gui_",
	"mouse_",
	
	// General prototype
	"player_controlled"
],

editor_info: { category: "Characters" },
solid_dimensions: ["player","common", "item"],
collide_dimensions: ["player", "common", "item"],
vehicle: false,
has_feet: false,
feet_width: null,
hitpoints: 10,
max_hitpoints: 10,
mass: 5,
is_human: true,
traction: 0,
no_move_to_standing: true,

zorder: "@include data/zorder.cfg:player",

properties: {
	/************
	 * INCLUDES *
	 ************/
	//"@derive": ["@flatten", "@include data/objects/player/blind_text_handler.cfg:properties", "@include data/objects/player/blind_gui.cfg:properties"],
/*	"@merge": '{"@flatten",
		"@include data/objects/player/mouse_.cfg:properties",
		"@include data/objects/player/shaders_.cfg:properties"
	}',*/
	//"@eval get_document('data/objects/player/blind_gui.json')",

	temp: { type: '[commands]', default: [] },
	set_temp: "commands :: set(temp, [commands :: debug('hi'), debug(' loser')])",

	// Make player walk slower when diagonal; sqrt(2) is due to Pythagorean's thrm.
	movespeed: "int(1*250.0/ if((UpOrDown) and (LeftOrRight), sqrt(2), 1))
			where LeftOrRight =
				ctrl_keyboard(keys['l']) or ctrl_keyboard(keys['r'])
			where UpOrDown =
				ctrl_keyboard(keys['d']) or ctrl_keyboard(keys['u'])
			",

	current_triggers: { type: 'int', default: 0 },
	//bumpPushback_: "int :: 2500",
	bumpPushback_: "int :: 0",
	bumpVolume_: "decimal :: 0.25",
	bumpCooldown_: "int :: 30",
	bumpOffset_: "int :: 5",
	// IMPORTANT: We want a bump cooldown so that a cornered player doesn't get crazy.
	time_of_last_hbump: { type: 'int', default: 0 },	// Horizontal bumps
	time_of_last_vbump: { type: 'int', default: 0 },	// Vertical bumps
	is_hbumpCooldown_: "bool ::
		if(level.cycle - time_of_last_hbump < bumpCooldown_, true, false)",
	is_vbumpCooldown_: "bool ::
		if(level.cycle - time_of_last_vbump < bumpCooldown_, true, false)",
	
	posthitInvincibilityPeriod_: "80",	
	hurt_velocity: "int :: 1000",
	
	// Player's solid area width/height
	// Used for level collisions from the side
	playerSize_:  "int :: 10",
	playerHeight_: "int :: 20",
	
	PlayerDamageResponse: "def(string damageType_,
							   int    amount, 
							   int    attacker_midpoint_x, 
							   int    attacker_midpoint_y) -> commands
	   [sound('player_hit.wav', global_volume-(0.04*2d3)),
		set(velocity_x, hurt_velocity * cos(angle)),
		set(velocity_y, hurt_velocity * sin(angle))]
			where angle = if(attacker_midpoint_x >= me.midpoint_x, 180.0, 0.0) +
				atan(decimal(attacker_midpoint_y - me.midpoint_y)/
					 decimal( max(attacker_midpoint_x - me.midpoint_x, 1) ))
	",
	
	// collideDir is the postfix
	DoBump: "def(string collideDir) -> commands [
		
		// Attempt to create the bump effect regardless of cooldowns, etc.	
		CreateBumpEffect(collideDir),
	
		// We want to
		//  1) make sure we aren't already pushing
		//  2) keep button mashing from creating the sound on top of itself
		//   2a) but it's okay if it comes from different directions
		//  3) make sure player is actually trying to walk in that direction(?)
		if( (animation != 'push_' + collideDir) and
			(not Timer_IsStarted(timerName) or Timer_HasExpired(timerName)) and
			(ctrl_keyboard(keys[collideDir])),
		[
				animation('push_' + collideDir),
				sound('bump.wav', bumpVolume_),
				Timer_Start(timerName, bumpCooldown_),
				
				add(velocity_x, -MakeForwardX(bumpPushback_)),
				add(velocity_y, -MakeForwardY(bumpPushback_)),
				
		]) where timerName = 'bump_' + collideDir
	]",
	
	// TODO: Make it so that it only gets rid of the bump of its
	// current facing.
	CreateBumpEffect: "def(string collideDir) -> commands [
		remove_object(filter(level.chars, value is obj bump)),
		
		if(is_blind,
			spawn(
				'bump',
				me.mid_x +
					MakeForwardX(playerSize_ + bumpOffset_, collideDir),
				me.mid_y +
					MakeForwardY(playerSize_ + bumpOffset_, collideDir) +
					upwardOffset__, // Compensate for the player popping 'out'
				{rotate: rotationTable__[collideDir]}
			)
		)
		where rotationTable__ =
			{string -> int} :: {'l': 0, 'u': 90, 'r': 180, 'd': 270 }
		where upwardOffset__ =
			if(collideDir = 'u', -20, 0)
	]",
	
	# -- String and List Manipulation -- #	
	tail: "def(string input) -> string
		if(input != '', input[:size(input)-1], input)",	// Drop last element
	behead: "def(string input) -> string
		input[1:]",				// Drop first

	
	# -- Extra keybinds -- #
	// Following three functions come out of frogatto_playable.cfg
	_key_store: { type: "{string|int -> int|null}", default: {} },
    track_key: "def(string|int key_name) ->commands if(key_name in ctrl_keys, if(not key_name in _key_store, add(_key_store, {(key_name): cycle})), set(_key_store[key_name], null))",
    ctrl_keyboard: "def(string|int key_name) ->int|null if(key_name in _key_store, (cycle - (int <- _key_store[key_name])), null )",

	keys: { type: '{string -> string}', default: {
		l: 'a',
		r: 'd',
		u: 'w',
		d: 's'} },
	all_keys: "map(keys, value)",
	all_actions: "keys(keys)",
},	#### EVENTS START HERE ####

on_create: "[animation('look_d'),
	set(invincible, 50),
	set(cycle, level.cycle),
	set(collide_dimensions_in, ['player', 'common', 'item']),
	set(solid_dimensions_in, ['player', 'common', 'item']),
	set(facing, 1),		// No flipping! Must always face the same direction
	set(time_last_hit, 0),
	set(time_of_last_hbump, -bumpCooldown_),
	set(time_of_last_vbump, -bumpCooldown_),
	set(desc_stack, { 0: ' ' }),
	
/*	fold(map(dialog_data, { key: construct('dialog_node', value) }), a+b, {})
		where dialog_data = { string -> map } <- get_document('data/dialog_nodes.cfg')*/
	set(seqLibrary, {
		'null': [],
		'hi': [debug('hi')],
		'go_left': map(range(1000), fire_event('input_l') ),
		'_go_right': map(range(1000), fire_event('input_r') )
	}),

	if(not is_blind, lights_on),
	display_choices({
		'Cycle':          'debug(level.player.cycle)',
		'Move right':     'add(level.player.mid_x, 10)',
		'Move left':      'add(level.player.mid_x, -10)',
		'SUPER MAN!!!':   'execute(level.player, die())',
		'manderin\nsoup': 'null'
	})
]",

on_start_level: "[
	set_up_gui(), 
	save_game(), 
	checkpoint_game(), 
	set(time_last_hit, 0),
	if(not desc_stack, set(desc_stack, { 0: ' ' })),
]",

on_load: "[
	set_up_gui(),
	set(time_last_hit, 0),
	if(not desc_stack, set(desc_stack, { 0: ' ' })),
]",

on_open_editor: "[tear_down_gui(), lights_on, destroy_choices]",
on_close_editor: "[set_up_gui(), lights_off]",

on_change_solid_dimensions_fail: "[
	proto_event('player_controlled', 'change_solid_dimensions_fail'),
]",

# -- Player Inputs and Animations -- #
//on_click: "debug(mouse_x)",
//on_mouse_enter: "debug(arg.mouse_x)",

on_process: "[
	/*debug(mouseAngle_, FindQuad(mouseX_, mouseY_) )
		where quadrentAdjustment_ = [0, 180, 180, 360][FindQuad(mouseXY_[0], mouseXY_[1]) - 1]
			,*/
		
	map(all_keys, track_key(value)),	// Keep track of all our assigned keybinds

	set(velocity_x, velocity_x/4),	// This replaces friction	
	set(velocity_y, velocity_y/4),
	
	set(level.camera_position, [
		midpoint_x - camera_width/2,
		midpoint_y - camera_heigth/2
	])  where camera_width = level.camera_position[2]
		where camera_heigth = level.camera_position[3],
	
	//Fire input events such as 'input_u', 'input_d', etc. 
	if(not isBusy_, map(all_actions,
			if(ctrl_keyboard(keys[value]), fire_event('input_'+value))
		)
	),
	
	// Keep the sequence alive
	UpdateSeq()
]",

timer_frequency: 2,
on_timer: "[
	// Handle ending of invincibility.
	if((level.cycle - time_last_hit)/2 <= 50 and (level.cycle - time_last_hit)/2 > 1,
		set(solid_dimensions_in, ['player', 'common'])),
	if(not is_invincible_posthit, set(alpha,255), set(solid_dimensions_in, [])),
	
	// Manage desc_stack and friends
	if(desc_stack_needs_update, update_desc_stack)
]",

// Manage player's collisions w/ walls
// The 'collide_side' event is flawed in that it cannot detect where the player
// had the collision.
on_collide_side: "
	if( solid(level,
		mid_x - playerSize_ - 8,
		mid_y - playerHeight_/2,
		1, playerHeight_),	// The width/height
			DoBump('l'),
			DoBump('r')
	)
",
on_collide_feet: "DoBump('d')",
on_collide_head: "DoBump('u')",

on_input_u:    "[add(velocity_y, -movespeed),
				  if(animType_ = 'look', animation('walk_u'))]",
on_process_walk_u: "if(not ctrl_keyboard(keys['u']), animation('look_u'))",
on_end_walk_u_anim: "animation('walk_u')",
on_process_push_u: "if(not ctrl_keyboard(keys['u']), animation('look_u'))",
on_end_push_u_anim: "animation('look_u')",

on_input_d:  "[add(velocity_y, movespeed),
				  if(animType_ = 'look', animation('walk_d'))]",
on_process_walk_d: "if(not ctrl_keyboard(keys['d']), animation('look_d'))",
on_end_walk_d_anim: "animation('walk_d')",
on_process_push_d: "if(not ctrl_keyboard(keys['d']), animation('look_d'))",
on_end_push_d_anim: "animation('look_d')",

on_input_r: "[add(velocity_x, movespeed),
				  if(animType_ = 'look', animation('walk_r'))]",
on_process_walk_r: "if(not ctrl_keyboard(keys['r']), animation('look_r'))",
on_end_walk_r_anim: "animation('walk_r')",
on_process_push_r: "if(not ctrl_keyboard(keys['r']), animation('look_r'))",
on_end_push_r_anim: "animation('look_r')",

on_input_l:  "[add(velocity_x, -movespeed),
				  if(animType_ = 'look', animation('walk_l'))]",
on_process_walk_l: "if(not ctrl_keyboard(keys['l']), animation('look_l'))",
on_end_walk_l_anim: "animation('walk_l')",
on_process_push_l: "if(not ctrl_keyboard(keys['l']), animation('look_l'))",
on_end_push_l_anim: "animation('look_l')",

#ANIMATIONS#
animation: [
	{
		"@base": true,		
		image: "characters/mage.png",
		solid_area: [8,15,18,25],		
		body_area: [8,15,18,25],		
		pad: 3,
	},

	# -- Walking and Looking -- #
	{
		id: "look_d",		
		rect: [90, 3, 115, 27],
		frames: 1,
		frames_per_row: 8,
		duration: 6,
	},

	{
		id: "look_u",
		rect: [208, 3, 233, 28],
		frames: 1,
		frames_per_row: 4,
		duration: 8,
	},
	
	{
		id: "look_r",
		rect: [90, 34, 115, 59],
		frames: 1,
		frames_per_row: 4,
		duration: 8,
	},

	{
		id: "look_l",
		rect: [150, 34, 175, 59],
		frames: 1,
		frames_per_row: 4,
		duration: 8,
	},
	
	{
		image: "characters/player.png",
		id: "walk_d",
		rect: [3, 33, 27, 58],
		frames: 4,
		frames_per_row: 4,
		duration: 9,
	},
	
	{
		image: "characters/player.png",
		id: "walk_u",
		rect: [116, 33, 140, 58],
		frames: 4,
		frames_per_row: 4,
		duration: 9,
	},

	{
		id: "walk_r",
		rect: [3, 34, 28, 59],
		frames: 4,
		frames_per_row: 4,
		duration: 9,
	},
	
	{
		id: "walk_l",
		rect: [121, 34, 146, 59],
		frames: 4,
		frames_per_row: 4,
		duration: 9,
	},

	{
		id: "push_d",
		rect: [3, 3, 28, 28],
		frames: 4,
		frames_per_row: 4,
		duration: 15,
	},
	
	{
		id: "push_u",
		rect: [121, 3, 146, 28],
		frames: 4,
		frames_per_row: 4,
		duration: 15,
	},

	{
		id: "push_r",
		rect: [3, 34, 28, 59],
		frames: 4,
		frames_per_row: 4,
		duration: 15,
	},
	
	{
		id: "push_l",
		rect: [121, 34, 146, 59],
		frames: 4,
		frames_per_row: 4,
		duration: 15,
	},

	# -- Magic Weilding -- #			
	{
		id: "begin_prepare",
		rect: [3, 3, 27, 27],
		frames: 1,
		frames_per_row: 1,
		duration: 25,
	},
	
	{
		id: "prepare",
		rect: [209, 65, 234, 90],
		frames: 1,
		frames_per_row: 1,
		duration: 1,
	},
	
	{
		id: "cast3",
		rect: [209, 65, 234, 90],
		frames: 1,
		frames_per_row: 1,
		duration: 30,
	},
	
	{
		id: "cast_d",
		rect: [61, 65, 86, 90],
		frames: 1,
		frames_per_row: 3,
		duration: 20,
		//duration: 12,
	},
	
	{
		id: "cast_u",
		rect: [150, 65, 175, 90],
		frames: 1,
		frames_per_row: 3,
		duration: 20,
	},
	
	{
		id: "cast_r",
		rect: [61, 94, 86, 119],
		frames: 1,
		frames_per_row: 3,
		duration: 20,
	},
	
	{
		id: "cast_l",
		rect: [150, 94, 175, 119],
		frames: 1,
		frames_per_row: 3,
		duration: 20,
	},
	# -- Items -- #			
	{
		id: "item_get_begin",
		rect: [3, 3, 27, 27],
		frames: 1,
		frames_per_row: 1,
		duration: 25,
	},	
				
	{
		id: "item_get_end",
		rect: [3, 3, 27, 27],
		frames: 1,
		frames_per_row: 1,
		duration: 25,
	},
],

object_type: [
{
		id: "prepare_spell_dialogue",
		// This will get filled out later, when a
		// more user friendly dialogue is worked out.
		//
		// This object will create several text objects, and then
		// this object will die when those objects are done.
		//   (killing the text objects in the process.)
},
	
{
	id: "firebolt",
	dies_on_inactive: true,
	timer_frequency: 450,
	object_level_collisions: true,
	solid_dimensions: ["enemy"],
	collide_dimensions: ["enemy"],
	prototype: ["shot"],
	properties: {
	        attackDamage: "2",
	        team_: "'player'",
	},
	
	on_end_normal_anim: "animation('normal')",
	on_process: "if((time_in_animation%7) = 0, spawn('blind_playable.firebolt_trail',midpoint_x,midpoint_y,{velocity_x:0,velocity_y:0}))",
	on_end_flash_anim: "die()",
	on_timer: "die()",
	animation:
		{
		id: "normal",
		image: "effects/magic_fire.png",
		attack_area: [1,1,6,6],
		pad: 3,
		rect: [2,2,10,10],
		frames: 4,
		frames_per_row: 4,
		duration: 5
	    },
},
	
{
	id: "firebolt_trail",
	ignore_collide: true,
	on_end_normal_anim: "die()",
    
	zorder: -5,
	dies_on_inactive: true,
	on_spawned: "animation('normal')",

	animation:
	    {
		id: "normal",
		image: "effects/magic_fire.png",
		pad: 3,
		rect: [2, 14, 6, 18],
		frames: 4,
		frames_per_row: 5,
		duration: 4,
		x_accel: 0,
		y_accel: 0
	    },
},
	
{
	id: "fireball",
	dies_on_inactive: true,
	timer_frequency: 450,
	object_level_collisions: true,
	solid_dimensions: ["enemy"],	
	collide_dimensions: ["enemy"],
	prototype: ["shot"],
	properties: {
	        attackDamage: "1",
	        team_: "'player'",
	},
	
	on_create: "[if(
		velocity_x > 0, set(facing, 1),
		velocity_x < 0, [set(facing, -1), add(x, -20)],
		velocity_y < 0, [animation('normalup'), add(x, -7), add(y, -15)],
		velocity_y > 0, [animation('normaldown'), add(x, -9), add(y, 13)],
		0),
		if(velocity_y != 0, add(x, 0))]",
	on_end_normal_anim: "animation('normal')",	
	on_end_normalup_anim: "animation('normalup')",
	on_end_normaldown_anim: "animation('normaldown')",
	on_end_flash_anim: "die()",
	on_timer: "die()",
	
	on_die: "spawn('blind_playable.fireball_explosion',midpoint_x,midpoint_y, {},
		[map(range(8), value,
			schedule(1d8, spawn('blind_playable.fireball_explosion',midpoint_x + radius*cos(value*45),midpoint_y + radius*sin(value*45), {}))
		where radius = 55)
	])",
	
	animation: [
		{
		id: "normal",
		image: "effects/magic_fire.png",		
		attack_area: [7,-1,16,7],
		solid_area: [9,1,14,5],
		pad: 2,
		rect: [2,22,17,30],
		frames: 3,
		frames_per_row: 4,
		duration: 5
	    },
	    
		{
		id: "normalup",
		image: "effects/magic_fire.png",		
		attack_area: [-1,-2,9,7],
		solid_area: [1,0,7,5],
		pad: 1,
		rect: [118,1,126,17],
		frames: 3,
		frames_per_row: 1,
		duration: 5
	    },
	    
		{
		id: "normaldown",
		image: "effects/magic_fire.png",		
		attack_area: [-1,8,9,17],
		solid_area: [1,10,7,15],
		pad: 1,
		rect: [108,1,116,17],
		frames: 3,
		frames_per_row: 1,
		duration: 5
	    },	    
	]
},

{
	id: "fireball_explosion",
	prototype: ["hittable"],
	solid_dimensions: ["enemy"],	
	collide_dimensions: ["enemy"],
	on_end_normal_anim: "die()",
    
	zorder: 50,
	dies_on_inactive: true,
	on_spawned: "[animation('normal'), set(custom_draw, [1.0, 2.0, 3.0, 4.0, [v,-v], [v,v], [-v,v], [-v,-v]]) where v = 0]",
	properties: {
	        attackDamage: "1",
	        team_: "'player'",
	        damageCooldown_: "6",
	},
	
	on_create: "sound('explode.wav', 0.03 + (0.01*1d5))",

	animation:
	    {
		id: "normal",
		image: "effects/magic_fire.png",		
//		attack_area: [-14,-14,36,36],	// Center is 11
		attack_area: [0,-1,22,22],
		pad: 2,
		rect: [2,34,24,56],
		frames: 4,
		frames_per_row: 4,
		duration: 2,
		y_accel: 0
	    },
},
],

}
