{
id: "sequence_handler_",

properties:
{
	/*************
	 * SEQUENCES *
	 *************/
	
	/**************************************************************************
	 * Sequences are a way to manage game events, and is very closely tied with
	 * the game's dialog. Sequences aren't actually connected to the dialog
	 * functions at all, however, and can be used independantly. (This is
	 * because sequences accept functions rather than strings, etc.)
	 *
	 *
	 * ---OVERVIEW-------------------------------------------------------------
	 * At the heart of this system is the seqLibrary_, which is probably loaded
	 * from a file, and contains almost all of the game's dialog. (Or
	 * references to the files which contain dialog.) The sequences are
	 * referenced with a currentSeqName, while individual sequences are lists
	 * of commands which are executed sequentially, once per frame. (Or until
	 * seqIsBusy becomes false. See below.)
	 *
	 *
	 * ---MAKING SEQUENCES WORK------------------------------------------------
	 * In order for sequences to work, UpdateSequence() must be run in
	 * on_process. Otherwise, it will get neglected and die. In order to start
	 * a new sequence, just call StartSeq() with the requested seqence name as
	 * an argument. This won't work for uninterruptible sequences.
	 *
	 *
	 * ---INTERRUPTIBLE SEQUENCES----------------------------------------------
	 * Some sequences are considered uninterruptible, meaning that StartSeq()
	 * will do nothing UNLESS the sequence has been completed. This is helpful
	 * for vital story scenes, but not so much for chitchat. To make a sequence
	 * uninterruptible, start the name with an underscore.
	 * 
	 *
	 * ---BUSY SEQUENCE EXPLANATION--------------------------------------------
	 * When seqIsBusy becomes true, then sequences STOP RUNNING until this
	 * boolean is set back to false. This can be EXTREMELY DANGEROUS,
	 * especially in the case of uninterruptible sequences. If you want to do
	 * this, typically, you'll want to nest a list (in which case all of the
	 * nested commands will run together). To keep things from hanging up, you
	 * have to set seqIsBusy either with the commands run or by some outside
	 * source.
	 *
	 **************************************************************************/
	
	// SeqLibrary_ is at the bottom.
	
	currentSeqName: { type: 'string', default: 'null'},// Ref. to current sequence
	seqIndex:       { type: 'int'   , default: 0},	 // Index into current seq.
	seqIsBusy:	  { type: 'bool'  , default: false},
	
	// Handy properties
	currentSeq_: "[commands] :: seqLibrary_[currentSeqName]",
	
	// Most of the time, sequences are interruptable. Sometimes, though, they
	// are not. In such a case, it can only be interrupted if it's finished.
	currentSeqIsInterruptible: "bool :: (
		currentSeqName[0] != '_' or
		seqIndex >= size(seqLibrary_[currentSeqName])
	)",
	
	// Functions
	/**************************************************************************
	 *   StartSeq:
	 * This function's goal is mainly to run a sequence. It doesn't actually do
	 * anything; it just lets UpdateSeq run on its marry way. This function
	 * cannot check whether the sequence exists or not; if it did so, it would
	 * cause a world-ending infinite loop.
	 **************************************************************************/
	StartSeq: "def(string requestedSeqName) -> commands
		if(currentSeqIsInterruptible and
		   requestedSeqName != currentSeqName,
			[   set(currentSeqName, requestedSeqName),
				set(seqIndex, 0),
				set(seqIsBusy, false)
			],
		)
	",
	
	UpdateSeq: "def() -> commands
		if( not seqIsBusy and seqIndex < size(currentSeq_),
			[   currentSeq_[seqIndex],	// Run current set of commands
				add(seqIndex, 1)		  // Advance the index
			]
		)
	",


	/*******************
	 * PRIORITY SYSTEM *
	 *******************/
	// This manages which object's events fire in the case of overlapping.
	priorityCue: { type: '{int -> commands|null}', default: {} },
	greatestPriority_: "int|null ::
		choose(
			filter(keys(priorityCue), priorityCue[value] != null),
			value
		)
	",
	
	/*************************************************************************
     *   NewPriority:
     * This function adds a new priority to the cue, assuming that given
     * priority number isn't already taken. If the priority is the greatest
     * one in the list, then it will activate once. Otherwise, it is silently
     * added and nothing else happens.
     *************************************************************************/
	NewPriority: "def(int priority, commands opp) -> commands
		if(priorityCue[priority] = null, // If it's not there, we get null anyway
			[   if(priority > greatestPriority_,
					opp
				),
				set(priorityCue[priority], opp)
			]
		)
	",
	
	/*************************************************************************
     *   RemovePriority:
     * This function removes a entry in the priority cue. If that entry used
     * to be in the highest priority, then the next-highest priority is run
     * in its place.
     *************************************************************************/
	RemovePriority: "def(int priority) -> commands
		if(priority in keys(priorityCue),
			if(priority = greatestPriority_,
			[   set(priorityCue[priority], null);
				priorityCue[greatestPriority_]
			],
				set(priorityCue[priority], null)
			)
		)
	",


	// LIBRARY
	seqLibrary_: "{ string -> [commands] } :: {
		// General
		'null': [],
		'cycle': [debug(cycle), debug(cycle)],
		'clear desc': [lp.AddDesc('', true)],

		// test01
		'Check Hole': [
			lp.AddDesc(
			 ~You can't go any futher\!\n~ +
			 ~From the chasm, you hear a quiet voice...~,
			 true, true
			),

			lp.AddDial(
			 ~???: _W5_Do you wish to enter the catacombs?_W_~,
			 false, true
			),

			lp.CreateChoices({
			 'Yes': debug(~hi~),
			 'No' : lp.AddDial(~???: Coward...~, true)
			}),
		],
		
		// test02
		'Gate button': [
			lp.AddDesc(
			 ~There\'s an oval-shaped button on the wall.~,
			 true, true
			),

			[	set(lp.seqIsBusy, true),
				lp.CreateChoices({
				 'Push it': [lp.StartSeq('Toggle gate'),
				 			 set(lp.seqIsBusy, false),
							 lp.AddDesc('', true)
							],
				}),
			],
		],

		'Toggle gate': [
			// Bypassed possibility of null
			if(get_object(level, 'Gate controller') != null,
				fire_event(gc, 'toggle_solidity'), 
			)
				
		] where gc = get_object_or_die(level, 'Gate controller'),

	} where lp = level.player",

} // End of properties

} // End of file
