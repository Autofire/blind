{
id: "sequence_handler_",

properties:
{
	/*************
	 * SEQUENCES *
	 *************/
	
	/**************************************************************************
	 * Sequences are a way to manage game events, and is very closely tied with
	 * the game's dialog. Sequences aren't actually connected to the dialog
	 * functions at all, however, and can be used independantly. (This is
	 * because sequences accept functions rather than strings, etc.)
	 *
	 *
	 * ---OVERVIEW-------------------------------------------------------------
	 * At the heart of this system is the seqLibrary, which is probably loaded
	 * from a file, and contains almost all of the game's dialog. (Or
	 * references to the files which contain dialog.) The sequences are
	 * referenced with a currentSeqName, while individual sequences are lists
	 * of commands which are executed sequentially, once per frame. (Or until
	 * seqIsBusy becomes false. See below.)
	 *
	 *
	 * ---MAKING SEQUENCES WORK------------------------------------------------
	 * In order for sequences to work, UpdateSequence() must be run in
	 * on_process. Otherwise, it will get neglected and die. In order to start
	 * a new sequence, just call StartSeq() with the requested seqence name as
	 * an argument. This won't work for uninterruptible sequences.
	 *
	 *
	 * ---INTERRUPTIBLE SEQUENCES----------------------------------------------
	 * Most sequences are considered uninterruptible, meaning that StartSeq()
	 * will fail UNLESS the sequence has been completed. This is helpful for
	 * vital story scenes, but not so much for chitchat. To make a sequence
	 * interruptible, simply start the name with an underscore.
	 * 
	 *
	 * ---BUSY SEQUENCE EXPLANATION--------------------------------------------
	 * When seqIsBusy becomes true, then sequences STOP RUNNING until this
	 * boolean is set back to false. This can be EXTREMELY DANGEROUS,
	 * especially in the case of uninterruptible sequences. If you want to do
	 * this, typically, you'll want to nest a list (in which case all of the
	 * nested commands will run together). To keep things from hanging up, you
	 * have to set seqIsBusy either with the commands run or by some outside
	 * source.
	 *
	 **************************************************************************/
	
	seqLibrary:	 { type: '{string -> [commands]}', default: {} },
	
	currentSeqName: { type: 'string', default: 'null'},// Ref. to current sequence
	seqIndex:       { type: 'int'   , default: 0},	 // Index into current seq.
	seqIsBusy:	  { type: 'bool'  , default: false},
	
	// Handy properties
	currentSeq_: "[commands] :: seqLibrary[currentSeqName]",
	
	// Functions
	currentSeqIsInterruptible: "bool :: (
		seqIndex >= size(seqLibrary[currentSeqName]) or
		currentSeqName[0] = '_'
	)",
	
	StartSeq: "def(string requestedSeqName) -> commands
		if(currentSeqIsInterruptible and requestedSeqName != currentSeqName,
			[   set(currentSeqName, requestedSeqName),
				set(seqIndex, 0),
				set(seqIsBusy, false)
			],
		) asserting requestedSeqName in keys(seqLibrary)
	",
	
	UpdateSeq: "def() -> commands
		if( not seqIsBusy and seqIndex < size(currentSeq_),
			[   currentSeq_[seqIndex],	// Run current set of commands
				add(seqIndex, 1)		  // Advance the index
			]
		)
	",
	
} // End of properties

} // End of file
