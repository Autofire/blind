{
id: "sequence_handler_",

properties:
{
	/*************
	 * SEQUENCES *
	 *************/
	
	/**************************************************************************
	 * Sequences are a way to manage game events, and is very closely tied with
	 * the game's dialog. Sequences aren't actually connected to the dialog
	 * functions at all, however, and can be used independantly. (This is
	 * because sequences accept functions rather than strings, etc.)
	 *
	 *
	 * ---OVERVIEW-------------------------------------------------------------
	 * At the heart of this system is the seqLibrary_, which is probably loaded
	 * from a file, and contains almost all of the game's dialog. (Or
	 * references to the files which contain dialog.) The sequences are
	 * referenced with a currentSeqName, while individual sequences are lists
	 * of commands which are executed sequentially, once per frame. (Or until
	 * seqIsBusy becomes false. See below.)
	 *
	 *
	 * ---MAKING SEQUENCES WORK------------------------------------------------
	 * In order for sequences to work, UpdateSequence() must be run in
	 * on_process. Otherwise, it will get neglected and die. In order to start
	 * a new sequence, just call StartSeq() with the requested seqence name as
	 * an argument. This won't work for uninterruptible sequences.
	 *
	 *
	 * ---INTERRUPTIBLE SEQUENCES----------------------------------------------
	 * Most sequences are considered uninterruptible, meaning that StartSeq()
	 * will fail UNLESS the sequence has been completed. This is helpful for
	 * vital story scenes, but not so much for chitchat. To make a sequence
	 * interruptible, simply start the name with an underscore.
	 * 
	 *
	 * ---BUSY SEQUENCE EXPLANATION--------------------------------------------
	 * When seqIsBusy becomes true, then sequences STOP RUNNING until this
	 * boolean is set back to false. This can be EXTREMELY DANGEROUS,
	 * especially in the case of uninterruptible sequences. If you want to do
	 * this, typically, you'll want to nest a list (in which case all of the
	 * nested commands will run together). To keep things from hanging up, you
	 * have to set seqIsBusy either with the commands run or by some outside
	 * source.
	 *
	 **************************************************************************/
	
	// SeqLibrary_ is at the bottom.
	
	currentSeqName: { type: 'string', default: 'null'},// Ref. to current sequence
	seqIndex:       { type: 'int'   , default: 0},	 // Index into current seq.
	seqIsBusy:	  { type: 'bool'  , default: false},
	
	// Handy properties
	currentSeq_: "[commands] :: seqLibrary_[currentSeqName]",
	
	// Functions
	currentSeqIsInterruptible: "bool :: (
		seqIndex >= size(seqLibrary_[currentSeqName]) or
		currentSeqName[0] = '_'
	)",
	
	StartSeq: "def(string requestedSeqName) -> commands
		if(currentSeqIsInterruptible and requestedSeqName != currentSeqName,
			[   set(currentSeqName, requestedSeqName),
				set(seqIndex, 0),
				set(seqIsBusy, false)
			],
		) asserting requestedSeqName in keys(seqLibrary_)
	",
	
	UpdateSeq: "def() -> commands
		if( not seqIsBusy and seqIndex < size(currentSeq_),
			[   currentSeq_[seqIndex],	// Run current set of commands
				add(seqIndex, 1)		  // Advance the index
			]
		)
	",
	

	/*******************
	 * PRIORITY SYSTEM *
	 *******************/
	// This manages which object's events fire in the case of overlapping.
	_priorityCue: { type: '{int -> commands|null}', default: {} },
	_greatestPriority: "int|null ::
		choose(
			filter(keys(_priorityCue), _priorityCue[value] != null),
			value
		)
	",
	
	/*************************************************************************
     *   NewPriority:
     * This function adds a new priority to the cue, assuming that given
     * priority number isn't already taken. If the priority is the greatest
     * one in the list, then it will activate once. Otherwise, it is silently
     * added and nothing else happens.
     *************************************************************************/
	NewPriority: "def(int priority, commands opp) -> commands
		if(priority in keys(_priorityCue) or _priorityCue[priority] = null,
			[   if(priority > _greatestPriority,
					opp
				),
				set(_priorityCue[priority], opp)
			]
		)
	",
	
	/*************************************************************************
     *   RemovePriority:
     * This function removes a entry in the priority cue. If that entry used
     * to be in the highest priority, then the next-highest priority is run
     * in its place.
     *************************************************************************/
	RemovePriority: "def(int priority) -> commands
		if(priority in keys(_priorityCue),
			if(priority = _greatestPriority,
			[   set(_priorityCue[priority], null);
				_priorityCue[_greatestPriority]
			],
				set(_priorityCue[priority], null)
			)
		)
	",


	// LIBRARY
	seqLibrary_: "{ string -> [commands] } :: {
		'null': [],
		'hi': [debug(cycle), debug(cycle)],
		'go_left': map(range(1000), fire_event('input_l') ),
		'_go_right': map(range(1000), fire_event('input_r') ),
		'Say Hi': [AddText(dialog, 'hi')],


		// test_1
		'pipe': [level.player.AddDesc('There is a pipe coming out of this wall.')],
	}",

} // End of properties

} // End of file
