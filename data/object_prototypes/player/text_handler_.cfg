{
id: "text_handler_",

properties: {
//	"@derive": "@include data/objects/player/gui.blind.cfg:properties",
	

	
	
	
	// OLD
	describe: "def(string text) -> commands
		gui_description_writer.add_text(text)",
	clear_describe: "def() -> commands
		gui_description_writer.clear_everything",
	force_describe: "def(string text) -> commands
		[clear_describe(),
		gui_description_writer.add_text(text)]",
	
	_dialog: "def(string text, string speaker='') -> commands
		gui_dialog_writer.add_text(text, speaker)",
	clear_dialog: "def() -> commands
		gui_dialog_writer.clear_everything",
	force_dialog: "def(string text, string speaker='') -> commands
		[clear_dialog(),
		gui_dialog_writer.add_text(text, speaker)]",

	// In addition to the basic functions which manage the
	// text-displayers, this is another layor on top of that,
	// intended for nested description areas. When a source wants
	// to have our attention, then the text from that source gets
	// displayed. As soon as another source has something to say,
	// it gets displayed. However when that second source goes
	// quiet, we might still want that first source to become
	// visible again.
	// 
	// Every string is mapped to a number. The string with the
	// highest number wins, and gets displayed. The zero-ith
	// string is ignored.
	//
	// The one caveat is that changes to the same priority aren't
	// displayed until changing away and then back. That way, two
	// objects may share priorities (and strings) and not cause
	// shenanaghans.
	
	desc_stack: { type: '{int -> string}', dynamic_initialization: true },
	//desc_stack: { type: '{int -> string}', init: { 0: ' ' } },	// I do not work
	
	add_desc_stack: "def(int priority, string text) -> commands [
		add(desc_stack, { (priority): text }),

		// Only cause update if new priority is above
		if(priority > max(keys(desc_stack)),
			set(desc_stack_needs_update, true)
		)
	]",
	
	remove_desc_stack: "def(int priority) -> commands [
		if(priority in keys(desc_stack),
			set(desc_stack,
				fold( map(keys(desc_stack), if(value=priority, {0: ' '}, {(value): desc_stack[value]}) ), a+b) )
		),
		
		// Only cause update if removed priority was the maximum
		if(priority = max(keys(desc_stack)),
			set(desc_stack_needs_update, true)
		)
	] where stack_element = {int -> string} <-
						if(value=priority, {(value): desc_stack[value]}, {0: ' '})",

	// The reason for this flag is so that we do not continue to push text onto the display
	desc_stack_needs_update: { type: 'bool', default: false },
	clear_desc_stack: "set(me.desc_stack, {0: ' '})",
	update_desc_stack: "[if(desc_stack != {0: ' '},
		force_describe( desc_stack[max(keys(desc_stack))] ),
		clear_describe()
	),
	set(desc_stack_needs_update, false)]",
} // End of Properties

} // End of file
