{
id: "text_handler_",

properties: {
	
	// TODO: Add support for speaker variable?

	// These are aliases that make it much easier to work with this stuff.
	describe: "obj text_writer :: guiDescriptionWriter",
	dialog:   "obj text_writer :: guiDialogWriter",

	//   AddText:
	// This function will add text to the specified obect. See arguments
	// and text_writer.cfg for more help.
	AddText: "def(obj text_writer target,	// Use `describe` or `dialog`
				  string text,				// Text to display
				  bool   forcePage  = false)// If true, empty buffer
				  						-> commands [
		
		// If we're forcing, change page instantly; it's probably important
		if(forcePage,
			set(target.buffer, '_p2_' + text),
			set(target.buffer, target.buffer + '_p_' + text),
		)
	]",



	
	_priorityCue: { type: '{int -> [commands]|null}', default: {} },
	_greatestPriority: "int|null ::
		choose(
			filter(keys(_priorityCue), _priorityCue[value] != null),
			value
		)
	",
	
	/*************************************************************************
     *   NewPriority:
     * This function adds a new priority to the cue, assuming that given
     * priority number isn't already taken. If the priority is the greatest
     * one in the list, then it will activate once. Otherwise, it is silently
     * added and nothing else happens.
     *************************************************************************/
	NewPriority: "def(int priority, [commands] code) -> commands
		if(priority in keys(_priorityCue) or _priorityCue[priority] = null,
			[   if(dump(priority > _greatestPriority),
					code
				),
				set(_priorityCue[priority], code)
			]
		)
	",
	
	/*************************************************************************
     *   RemovePriority:
     * This function removes a entry in the priority cue. If that entry used
     * to be in the highest priority, then the next-highest priority is run
     * in its place.
     *************************************************************************/
	RemovePriority: "def(int priority) -> commands
		if(priority in keys(_priorityCue),
			if(priority = _greatestPriority,
			[   set(_priorityCue[priority], null);
				_priorityCue[_greatestPriority]
			],
				set(_priorityCue[priority], null)
			)
		)
	",

	// In addition to the basic functions which manage the
	// text-displayers, this is another layor on top of that,
	// intended for nested description areas. When a source wants
	// to have our attention, then the text from that source gets
	// displayed. As soon as another source has something to say,
	// it gets displayed. However when that second source goes
	// quiet, we might still want that first source to become
	// visible again.
	// 
	// Every string is mapped to a number. The string with the
	// highest number wins, and gets displayed. The zero-ith
	// string is ignored.
	//
	// The one caveat is that changes to the same priority aren't
	// displayed until changing away and then back. That way, two
	// objects may share priorities (and strings) and not cause
	// shenanaghans.

/*	
	desc_stack: { type: '{int -> string}', dynamic_initialization: true },
	//desc_stack: { type: '{int -> string}', init: { 0: ' ' } },	// I do not work
	add_desc_stack: "def(int priority, string text) -> commands [
		add(desc_stack, { (priority): text }),

		// Only cause update if new priority is above
		if(priority > max(keys(desc_stack)),
			set(desc_stack_needs_update, true)
		)
	]",
	
	remove_desc_stack: "def(int priority) -> commands [
		if(priority in keys(desc_stack),
			set(desc_stack,
				fold( map(keys(desc_stack), if(value=priority, {0: ' '}, {(value): desc_stack[value]}) ), a+b) )
		),
		
		// Only cause update if removed priority was the maximum
		if(priority = max(keys(desc_stack)),
			set(desc_stack_needs_update, true)
		)
	] where stack_element = {int -> string} <-
						if(value=priority, {(value): desc_stack[value]}, {0: ' '})",

	// The reason for this flag is so that we do not continue to push text onto the display
	desc_stack_needs_update: { type: 'bool', default: false },
	clear_desc_stack: "set(me.desc_stack, {0: ' '})",
	update_desc_stack: "[if(desc_stack != {0: ' '},
		force_describe( desc_stack[max(keys(desc_stack))] ),
		clear_describe()
	),
	set(desc_stack_needs_update, false)]",
	*/
} // End of Properties

} // End of file
